变量、作用域和内存
     变量相关
     （1）ECMAScript变量的数据类型分为：基本数据类型和引用数据类型；
     （2）五种基本数据类型为：Undefined、Null、Boolean、Number、String，操作的是保存在变量中的实际的值；
     （3）引用类型的值是保存在内存中的对象，实际操作的是对象的引用，而不是保存在内存中的值；
     （4）只能给引用类型的变量添加动态属性，而基本数据类型和的变量虽然给其添加属性不会报错，但是在访问时为undefined；
     （5）在复制基本类型的变量时，两个操作数的值存储在相对独立的空间内；
     （6）检测基本数据类型用typeof，检测引用数据类型时用instanceof
     
     作用域相关
     （1）执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为；
     （2）某个执行环境中的代码执行完毕后，该环境被销毁，保存在其中的变量和函数也被销毁；
     （3）每个函数都有自己的执行环境， 执行流由一个存储执行环境的环境栈管理；
     （4）延长作用域链：try-catch的catch语句块（在catch中创建的变量会存入当前执行环境），with语句，会将指定     的对象添加到作用域中；
     （5）没有块级作用域；
     （6）使用var声明的变量会被自动添加到最近的环境中；
     （7）查询标识符（变量），遵循作用域链上就近查找原则，但如果在全局环境中都没有找到，那就意味着这个标识符并没有声明；
     
     垃圾回收
     （1）函数执行过程中，会为局部变量分配栈（堆）内存存储它们的值，当函数执行完毕后，就释放之前分配给局部变量的内存；
     （2）垃圾回收（一定时间的周期性执行）的两种策略：
          标记清除：先把内存中存储的所有变量打上标记，然后去除那些存在环境中和被环境中变量所引用的变量的标记，而在此之后再次被打上标记的变量将会变成准备删除的变量，原因是环境中的变量再也访问不到这些变量了，最后垃圾回收器回收这些带标记（标记 >=2层）的变量的内存空间；
          引用计数：当声明一个变量并将一个引用类型值赋值给该变量，则这个值的引用次数为1，如果同一个值被赋值给了另外一个变量，则该值的引用次数加1，相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1,。当这个值的引用次数变为0时，则说明该值已经无法被访问了，这时就会被释放内存；
                          引用计数存在一个严重的问题就是“循环引用”，导致这种类型引用的变量永远不会被释放，Navigatot4.0之后放弃了引用计数的策略；
                          因为IE9版本之前IE中的BOM和DOM并不是原生的JavaScript对象，而是使用C++中的COM对象的形式实现的，而COM采用的是引用计数的垃圾回收策略，因此一直存在着“循环引用”的问题，例如内存泄露等现象；
                         IE9之前的IE浏览器可以通过“手动断开”循环引用的方式避免COM“引用计数”的弊端（myObject = null）；
     （3）性能问题，IE7根据具体数量的类型变量达到临界值时触发垃圾收集器的运行。这种情况下，在一个包含那么多变量的脚本在运行时促使垃圾回收器频繁运行，导致了严重的性能问题，因此IE7推倒之前的做法，重做为临界值为动态修正，具体根据内存分配量的占比；
     （4）管理内存，因为系统分配给浏览器的内存要低于桌面应用，所以内存限制的问题会影响给变量分配内存，同时还会影响调用栈以及在一个线程内同时执行的语句数量。因此，为确保页面的性能，在数据不再有用时，手动置null释放其引用（解耦引用）是一个很好的内存管理方案；
     
     小结
     （1）基本数据类型的值，因为大小固定，存储在栈内存中；
     （2）引用数据类型的值是对象，存储在堆内存中；

